// SL 2020-04-28
// DoomChip!
//
// References:
// - "DooM black book" by Fabien Sanglard
// - "DooM unofficial specs" http://www.gamers.org/dhs/helpdocs/dmsp1666.html
//
// NOTE: for now the focus is on 'making it happen'
//     this will be followed by optimizations to fully exploit
//     FPGA parallelism (a great exercise!)
//
// TODO:
//   cleanup
//   update to use bitfields!
//   optimize         : - a lot of things could be parallelized / factored
//                        => drawing for floor/celing/lower/upper/middle
//                        => collisions
//                        => movable updates
//
// MIT license, see LICENSE_MIT in Silice repo root
// https://github.com/sylefeb/Silice

$$print('------< Compiling the DooM chip >------')
$$print('---< written in Silice by @sylefeb >---')

// SETUP select the wad file here
$$wad   = 'doom1.wad'
$$-- wad   = 'freedoom1.wad' -- works also with freedoom!

// SETUP select the level here!
$$level = 'E1M1'
$$dofile('pre_wad.lua')

$$dofile('pre_load_data.lua')
$$ -- dofile('pre_render_test.lua')

// SETUP texture resolution can be adjusted in pre_do_textures.lua
//       default tends to be fairly low to reduce synthesis time
$$dofile('pre_do_textures.lua')

// writes down the code generated by pre_do_textures
$texturechip$

$$dofile('pre_do_sprites.lua')

// fixed point precisions
$$FPl = 48
$$FPw = 24
$$FPm = 12

$$if ULX3S then
$$div_shrink = 1
$$else
$$div_shrink = 0
$$end

$$div_width  = FPl
$include('../common/divint_any.si')
$$mul_width  = FPw
$include('../common/mulint_any.si')

$$if DE10NANO then
$$INTERACTIVE = 1
$include('../common/keypad.si')
$$end

$$if ULX3S then
$$INTERACTIVE = 1
$$end

$$USE_DEBUG_POS = false

$$print('done reading game data')
$$print('(compiling takes a bit of time, please wait ...)')

// -------------------------
// some circuitry for repetitive things

circuitry to_h(input iv,output ov)
{
  ov = $doomchip_height//2$ + (iv >>> 15);
}

circuitry bbox_ray(input ray_x,input ray_y,input ray_dx_m,input ray_dy_m,
                   input bbox_x_lw,input bbox_x_hi,input bbox_y_lw,input bbox_y_hi,
                   output couldhit)
{
  couldhit = 1;
  if (ray_x > bbox_x_hi && ray_dx_m > __signed(0)) {
    couldhit = 0;
  }
  if (ray_x < bbox_x_lw && ray_dx_m < __signed(0)) {
    couldhit = 0;
  }
  if (ray_y > bbox_y_hi && ray_dy_m > __signed(0)) {
    couldhit = 0;
  }
  if (ray_y < bbox_y_lw && ray_dy_m < __signed(0)) {
    couldhit = 0;
  }
}

bitfield ZRec
{
  uint1     clear,
  uint$FPw$ depth,
}

// Selects a sprite based on angle
circuitry spriteSelect(input angle,input frame,output sprite,output mirror)
{
  // angle in 0 - 4095
  if (angle < 256) {
    sprite = frame * 5 + 2;
    mirror = 1;
  } else { if (angle < 768) {
    sprite = frame * 5 + 3;
    mirror = 1;
  } else { if (angle < 1280) {
    sprite = frame * 5 + 4;
    mirror = 0;
  } else { if (angle < 1792) {
    sprite = frame * 5 + 3;
    mirror = 0;
  } else { if (angle < 2304) {
    sprite = frame * 5 + 2;
    mirror = 0;
  } else { if (angle < 2816) {
    sprite = frame * 5 + 1;
    mirror = 0;
  } else { if (angle < 3328) {
    sprite = frame * 5 + 0;
    mirror = 0;
  } else { if (angle < 3840) {
    sprite = frame * 5 + 1;
    mirror = 1;
  } else {
    sprite = frame * 5 + 2;
    mirror = 1;
  } } } } } } } }
}

// Determines sector light level
circuitry sectorLightLevel(input bsp_secs_flats, output seclight)
{
    switch (bsp_secs_flats.rdata[24,8]) {
      case 1: { // random off
        if (rand < 256) {
          seclight = bsp_secs_flats.rdata[32,8]; // off (lowlight)
        } else {
          seclight = bsp_secs_flats.rdata[16,8]; // on (sector light)
        }
      }
      case 2: { // flash fast
        if ( (((time)>>4)&3) == 0 ) {
          seclight = bsp_secs_flats.rdata[16,8];
        } else {
          seclight = bsp_secs_flats.rdata[32,8];
        }
      }
      case 3: { // flash slow
        if ( (((time)>>5)&3) == 0 ) {
          seclight = bsp_secs_flats.rdata[16,8];
        } else {
          seclight = bsp_secs_flats.rdata[32,8];
        }
      }
      case 12: { // flash fast
        if ( (((time)>>4)&3) == 0 ) {
          seclight = bsp_secs_flats.rdata[16,8];
        } else {
          seclight = bsp_secs_flats.rdata[32,8];
        }
      }
      case 13: { // flash slow
        if ( (((time)>>5)&3) == 0 ) {
          seclight = bsp_secs_flats.rdata[16,8];
        } else {
          seclight = bsp_secs_flats.rdata[32,8];
        }
      }
      case 8: { // oscillates (to improve)
        if ( (((time)>>5)&1) == 0) {
          seclight = bsp_secs_flats.rdata[32,8];
        } else {
          seclight = bsp_secs_flats.rdata[16,8];
        }
      }
      default: {
        seclight = bsp_secs_flats.rdata[16,8];
      }
    }
}

// Determined light value from sector light and distance
circuitry lightFromDistance(input dist,output light)
{
  int$FPw$ tmp1 = uninitialized; // NOTE[Silice] here we would really like to be able to do "typeof(light) tmp1 = ..."
  int$FPw$ tmp2 = uninitialized;
  if (dist > 7) {
    tmp1 = 7;
  } else {
    tmp1 = dist;
  }
  tmp2 = seclight + tmp1;
  if (tmp2 > 31) {
    light = 31;
  } else { if (tmp2>=0) {
    light = tmp2;
  } else {
    light = 0;
  } }
}

// -------------------------
// Main drawing algorithm

algorithm doomchip(
  column_io colio {
    input   draw_col,
    output  y,
    output  palidx,
    output  write,
    output  done,
  },
  input uint1   vsync,
$$if ULX3S or DE10NANO then
  input  uint7  btns,
$$end
  output uint8  leds,
) <autorun> {

  // BRAMs for BSP tree
  bram uint64 bsp_nodes_coords[] = {
$$for _,n in ipairs(bspNodes) do
   $pack_bsp_node_coords(n)$, // dy=$n.dy$ dx=$n.dx$ y=$n.y$ x=$n.x$
$$end
  };

  bram uint32 bsp_nodes_children[] = {
$$for _,n in ipairs(bspNodes) do
   $pack_bsp_node_children(n)$, // lchild=$n.lchild$ rchild=$n.rchild$
$$end
  };

  bram uint128 bsp_nodes_boxes[] = {
$$for _,n in ipairs(bspNodes) do
   $pack_bsp_node_children_box(n)$, // left: $n.lbx_lw$,$n.lbx_hi$,$n.lby_lw$,$n.lby_hi$ right: $n.rbx_lw$,$n.rbx_hi$,$n.rby_lw$,$n.rby_hi$
$$end
  };

  // BRAMs for sectors
  bram uint48 bsp_secs[] = {
$$for _,s in ipairs(bspSectors) do
   $pack_bsp_sec(s)$,          // fth=$s.first_thing$ nth=$s.num_things$ c_h=$s.c_h$ f_h=$s.f_h$
$$end
  };

  bram uint40 bsp_secs_flats[] = {
$$for i,s in ipairs(bspSectors) do
   $pack_bsp_sec_flats(s)$,  // $i-1$] lowlight=$s.lowlight$ special=$s.special$ light=$s.light$ c_T=$s.c_T$ f_T=$s.f_T$
$$end
  };

  // BRAM for sub-sectors
  bram uint40 bsp_ssecs[] = {
$$for _,s in ipairs(bspSSectors) do
   $pack_bsp_ssec(s)$,         // parentsec=$s.parentsec$ start_seg=$s.start_seg$ num_segs=$s.num_segs$
$$end
  };

  // BRAMs for segments
  bram uint64 bsp_segs_coords[] = {
$$for _,s in ipairs(bspSegs) do
   $pack_bsp_seg_coords(s)$, // v1y=$s.v1y$ v1x=$s.v1x$ v0y=$s.v0y$ v0x=$s.v0x$
$$end
  };

  bram uint48 bsp_segs_tex_height[] = {
$$for i,s in ipairs(bspSegs) do
   $pack_bsp_seg_tex_height(s)$, // $i-1$] movableid=$s.movableid$ other_sec=$s.other_sec$ upr=$s.upr$ mid=$s.mid$ lwr=$s.lwr$
$$end
  };

  bram uint66 bsp_segs_texmapping[] = {
$$for i,s in ipairs(bspSegs) do
   $pack_bsp_seg_texmapping(s)$, // $i-1$] unpegged U$s.upper_unpegged$ L$s.lower_unpegged$ segsqlen/32=$s.segsqlen$ yoff=$s.yoff$ xoff=$s.xoff$ seglen=$s.seglen$
$$end
  };

  // BRAM for movables
  bram uint52 bsp_movables[] = {
   52h0, // first record is not used
$$for i,m in ipairs(bspMovables) do
   $pack_movable(m)$, // $i-1$] sec=$m.sec$ downh=$m.downh$ uph=$m.uph$
$$end
  };
$$if #bspMovables > 255 then error('more than 255 movables!') end
  uint8 num_bsp_movables = $1 + #bspMovables$;

  // BRAMs for things
  bram uint40 all_things[] = {
$$for i,th in pairs(allThings) do
   $pack_thing(th)$, // $i-1$] a=$th.a$ x=$th.x$ y=$th.y$
$$end
  };

  // BROM colormap
  $colormap$

  // BRAM for demo path
  bram uint64 demo_path[] = {
$$for _,s in ipairs(demo_path) do
   $pack_demo_path(s)$, // angle=$s.angle$ z=$s.z$ y=$s.y$ x=$s.x$
$$end
  };
  uint16 demo_path_len = $#demo_path$;

  // BRAM for floor/ceiling texturing ( 1/y table )
  bram int$FPw$ inv_y[$(doomchip_height//2)+1$]={
    1, // 0: unused
$$for hscr=1,doomchip_height//2 do
    $round((1<<(FPm))/hscr)$,
$$end
  };

  // BRAM for sine/cosine, could be made 1/4 of size, was lazy!
$$ sin_tbl = {}
$$ max_sin = ((2^FPm)-1)
$$for i=0,1023 do
$$   sin_tbl[i]        = round(max_sin*math.sin(2*math.pi*(i+0.5)/4096))
$$   sin_tbl[1024 + i] = round(math.sqrt(max_sin*max_sin - sin_tbl[i]*sin_tbl[i]))
$$   sin_tbl[2048 + i] = - sin_tbl[i]
$$   sin_tbl[2048 + 1024 + i] = - sin_tbl[1024 + i]
$$end
$$--for i=0,2047 do
$$--   print('sanity check: ' .. (math.sqrt(sin_tbl[i]*sin_tbl[i]+sin_tbl[i+1024]*sin_tbl[i+1024])))
$$--end

  bram int$FPm+1$ sin_m[4096] = {
$$for i=0,4095 do
    $sin_tbl[i]$,
$$end
  };

  // BRAM for x coord to angle
$$function col_to_x(i)
$$  return (doomchip_width/2-(i+0.5))*3/doomchip_width
$$end

  bram int13 coltoalpha[$doomchip_width$] = {
$$for i=0,doomchip_width-1 do
    $round(math.atan(col_to_x(i)) * (2^12) / (2*math.pi))$,
$$end
  };

$$xtoalpha_index_min = round(col_to_x(doomchip_width-1)*256)
$$xtoalpha_index_max = round(col_to_x(               0)*256)
$$xtoalpha_offset    = - xtoalpha_index_min
  bram int13 xtoalpha[$xtoalpha_index_max-xtoalpha_index_min+1$] = {
$$for x=round(col_to_x(doomchip_width-1)*256),round(col_to_x(0)*256),1 do
    $round(math.atan((x+0.5)/256.0) * (2^12) / (2*math.pi))$, // $x$
$$end
  };

  // BRAM for column to x coord
  bram int13 coltox[$doomchip_width$] = {
$$for i=0,doomchip_width-1 do
    $round(col_to_x(i)*256)$,
$$end
  };

  // Writes a pixel in the framebuffer, calls the texture unit
  subroutine writePixel(
     readwrites   colio,
     readwrites   depthBuffer,
     readwrites   colormap,
     calls        textures,
     output uint1 texopac,
     input  uint10 pi, input  uint10 pj,
     input  int16 tu,  input  int16 tv,
     input  uint8 tid, input  uint8 lit,
     input  int$FPw$ dist,
  ) {
    // initiate texture unit lookup (takes a few cycles)
    textures <- (tid,-tu,tv);
    // initiate depth buffer read
    depthBuffer.addr    = pj;
    depthBuffer.wenable = 0;
  ++: // read depth
    if (dist < ZRec(depthBuffer.rdata).depth || ZRec(depthBuffer.rdata).clear != pi[0,1]) {
      //                                                    clear toggle test ^^^^^
      // sync with texture unit
      (colio.palidx,texopac) <- textures;
      // lookup lighting
      colormap.addr = (tid == $texture_ids['F_SKY1'].id$) ? 94 : (colio.palidx + (lit<<8));
  ++:
      if (texopac) {
        // write!
        colio.palidx    = colormap.rdata;
  $$if doomchip_vflip then
        colio.y         = pj;
  $$else
        colio.y         = $doomchip_height-1$-pj;
  $$end
        colio.write     = 1;
        // update depth
        depthBuffer.wenable = 1;
        depthBuffer.wdata   = {pi[0,1], dist[0,$FPw$]};
      }
    }
  }

  // Writes a sprite pixel in the framebuffer
  subroutine writeSpritePixel(
     readwrites   colio,
     readwrites   depthBuffer,
     readwrites   colormap,
     input  uint10 pi, input uint10 pj,
     input  uint8  pix,  input uint8 lit,
     input  int$FPw$ dist
  ) {
    // NOTE: assumes depth buffer has been prepared (to save a cycle)
    if (dist < ZRec(depthBuffer.rdata).depth || ZRec(depthBuffer.rdata).clear != pi[0,1]) {
      //                                    clear toggle test ^^^^^
      // lookup lighting
      colormap.addr   = pix + (lit<<8);
  ++:
      // write!
      colio.palidx    = colormap.rdata;
  $$if doomchip_vflip then
      colio.y         = pj;
  $$else
      colio.y         = $doomchip_height-1$-pj;
  $$end
      colio.write     = 1;
      // update depth
      depthBuffer.wenable = 1;
      depthBuffer.wdata = {pi[0,1], dist[0,$FPw$]};
    }
  }

  // BROM with sprite data
  $spritebrom$

  // texture chip
  texturechip textures;

  uint16   stack[64] = uninitialized;
  uint9    stack_ptr = 0;

  int$FPw$ cosview_m  = 0;
  int$FPw$ sinview_m  = 0;
  int16    viewangle  = $player_start_a$;
  int16    colangle   = 0;

  int16    time     = 0;
  int16    frame    = 0;
  int16    ray_z    = 40;
  int16    target_z = 40;
  int16    ray_x    = $player_start_x$;
  int16    ray_y    = $player_start_y$;
  int$FPw$ ray_dx_m = 0;
  int$FPw$ ray_dy_m = 0;
  int16    lx       = 0;
  int16    ly       = 0;
  int16    ldx      = 0;
  int16    ldy      = 0;
  int16    col_rx   = 0;
  int16    col_ry   = 0;
  int16    dx       = 0;
  int16    dy       = 0;
  int$FPw$ csl      = 0;
  int$FPw$ csr      = 0;
  int16    v0x      = 0;
  int16    v0y      = 0;
  int16    v1x      = 0;
  int16    v1y      = 0;
  int$FPl$ cs0_h    = 0;
  int$FPl$ cs1_h    = 0;
  int$FPw$ invd_w   = 0;
  int$FPw$ interp_m = 0;
  int16    h        = 0;
  int16    sec_f_h  = 0;
  int16    sec_c_o  = 0;
  int$FPw$ sec_f_h_t = 0;
  int$FPw$ sec_c_h_t = 0;
  int$FPw$ sec_f_o_t = 0;
  int$FPw$ sec_c_o_t = 0;
  int$FPw$ f_h      = 0;
  int$FPw$ c_h      = 0;
  int$FPw$ f_o      = 0;
  int$FPw$ c_o      = 0;
  int16    tc_u     = 0;
  int16    xoff     = 0;
  int16    yoff     = 0;
  uint8    tmpid    = 0;
  uint8    seclight = 0;
  int$FPw$ atten    = 0;

  uint1    opac     = 0;

  div$FPl$ divl;
  mul$FPw$ mull;
  int$FPw$ mula     = 0;
  int$FPw$ mulb     = 0;
  int$FPl$ mulr     = 0;

  uint16   rchild    = 0;
  uint16   lchild    = 0;
  int16    bbox_x_lw = 0;
  int16    bbox_x_hi = 0;
  int16    bbox_y_lw = 0;
  int16    bbox_y_hi = 0;
  uint1    couldhit  = 0;

  int10    top = $doomchip_height$;
  int10    btm = 1;
  uint10   c   = 0;
  int10    j   = 0;
  uint8    palidx = 0;
  uint9    s   = 0;
  uint16   n   = 0;

  uint52   movabledata = 0;
  uint1    active = 0;
  uint1    has_switch = 0;

  uint1    viewsector = 1;
  uint1    walkable   = 1;
  uint1    onesided   = 1;
  uint1    colliding  = 0;
  uint8    onmovable  = 0;
  int$FPl$ onmovable_dist = 0;
  uint1    movableseg = 0;

  uint16   kpressed   = 0;
  uint5    kpressblind = 0;

  uint12   rand = 3137;

  bram uint$FPw+1$ depthBuffer[$doomchip_height$] = uninitialized; // MSB is a 'clear' toggle
  // it changes every column so we known whether the value is old (cleared) or
  // current.

  int16    debug0 = 0;
  int16    debug1 = 0;
  int16    debug2 = 0;
  int16    debug3 = 0;

$$if ULX3S or DE10NANO then
  uint7 btn_latch = 0;
$$if ULX3S then
  kpressed  := {1b0,1b0,1b0,btn_latch[2,1]/*fire2*/,btn_latch[6,1]/*right*/,btn_latch[5,1]/*left*/,btn_latch[4,1]/*dwn*/,btn_latch[3,1]/*up*/};
$$else
  kpressed  := {1b0,1b0,1b0,1b0,btn_latch[0,1]/*right*/,btn_latch[1,1]/*left*/,1b0/*dwn*/,btn_latch[2,1]/*up*/};
$$end
  btn_latch := btns;
  leds      := 0;
$$end

  colio.done  := 0; // maintain low (pulses high when needed)
  colio.write := 0; // maintain low (pulses high when needed)

  // brams in read mode
  bsp_nodes_coords   .wenable = 0;
  bsp_nodes_children .wenable = 0;
  bsp_nodes_boxes    .wenable = 0;
  bsp_secs           .wenable = 0;
  bsp_secs_flats     .wenable = 0;
  bsp_ssecs          .wenable = 0;
  bsp_segs_coords    .wenable = 0;
  bsp_segs_tex_height.wenable = 0;
  bsp_segs_texmapping.wenable = 0;
  bsp_movables       .wenable = 0;
  demo_path          .wenable = 0;
  inv_y              .wenable = 0;
  sin_m              .wenable = 0;
  coltoalpha         .wenable = 0;
  coltox             .wenable = 0;

  while (1) {

    // update position
$$if not INTERACTIVE and (not SIMULATION or USE_DEBUG_POS) then
  ray_x     = demo_path.rdata[ 0,16];
  ray_y     = demo_path.rdata[16,16];
  ray_z     = demo_path.rdata[32,16];
  viewangle = demo_path.rdata[48,16];
$$end

    col_rx = ray_x;
    col_ry = ray_y;

    // get cos/sin view
    sin_m.addr = (viewangle) & 4095;
++:
    sinview_m  = sin_m.rdata;
    sin_m.addr = (viewangle + 1024) & 4095;
++:
    cosview_m  = sin_m.rdata;

    // ----------------------------------------------
    // rendering
    // ----------------------------------------------
    c = 0;
    while (c < $doomchip_width$) {

      // -------
      // wait for drawer
      //__display("c = %d",c);
      while (c != colio.draw_col) { /*wait*/ }
      //__display("c passed = %d",c);

      // -------
      // prepare

      coltoalpha.addr = c;
      coltox    .addr = c;
++:
      colangle   = (viewangle + coltoalpha.rdata);

      // get ray dx/dy
      sin_m.addr = (colangle) & 4095;
++:
      ray_dy_m   = sin_m.rdata;
      sin_m.addr = (colangle + 1024) & 4095;
++:
      ray_dx_m   = sin_m.rdata;

      // set sin table addr to get cos(alpha)
      sin_m.addr = (coltoalpha.rdata + 1024) & 4095;

      top = $doomchip_height-1$;
      btm = 0;

      // -------
      // draw

      // init recursion
      stack[stack_ptr] = $root$;
      stack_ptr = 1;

      // let's rock!
      while (stack_ptr > 0) {

        stack_ptr = stack_ptr-1;
        n         = stack[stack_ptr];
        bsp_nodes_coords  .addr = n;
        bsp_nodes_children.addr = n;
        bsp_nodes_boxes   .addr = n;
++:
        if (n[15,1] == 0) {

          // internal node reached
          lx  = bsp_nodes_coords.rdata[0 ,16];
          ly  = bsp_nodes_coords.rdata[16,16];
          ldx = bsp_nodes_coords.rdata[32,16];
          ldy = bsp_nodes_coords.rdata[48,16];

          couldhit = 0;
          // which side are we on?
          dx   = ray_x - lx;
          dy   = ray_y - ly;
++: // relax timing
          csl  = (dx * ldy);
          csr  = (dy * ldx);
++: // relax timing
          if (csr > csl) {
            // front
            stack[stack_ptr  ] = bsp_nodes_children.rdata[ 0,16];
            bbox_x_lw          = bsp_nodes_boxes   .rdata[ 64,16];
            bbox_x_hi          = bsp_nodes_boxes   .rdata[ 80,16];
            bbox_y_lw          = bsp_nodes_boxes   .rdata[ 96,16];
            bbox_y_hi          = bsp_nodes_boxes   .rdata[112,16];
            (couldhit)         = bbox_ray(ray_x,ray_y,ray_dx_m,ray_dy_m,
                                          bbox_x_lw,bbox_x_hi,bbox_y_lw,bbox_y_hi);
            if (couldhit) {
              stack[stack_ptr+1] = bsp_nodes_children.rdata[16,16];
            }
          } else {
            // back
            stack[stack_ptr  ] = bsp_nodes_children.rdata[16,16];
            bbox_x_lw          = bsp_nodes_boxes   .rdata[  0,16];
            bbox_x_hi          = bsp_nodes_boxes   .rdata[ 16,16];
            bbox_y_lw          = bsp_nodes_boxes   .rdata[ 32,16];
            bbox_y_hi          = bsp_nodes_boxes   .rdata[ 48,16];
            (couldhit)         = bbox_ray(ray_x,ray_y,ray_dx_m,ray_dy_m,
                                          bbox_x_lw,bbox_x_hi,bbox_y_lw,bbox_y_hi);
            if (couldhit) {
              stack[stack_ptr+1] = bsp_nodes_children.rdata[ 0,16];
            }
          }
          stack_ptr = stack_ptr + 1 + couldhit;

        } else {

          // sub-sector reached
          bsp_ssecs      .addr = n[0,14];
++:
          bsp_secs       .addr = bsp_ssecs.rdata[24,16];
          bsp_secs_flats .addr = bsp_ssecs.rdata[24,16];
++:
          // light level in sector
          (seclight) = sectorLightLevel(bsp_secs_flats);

          // render column segments
          s = 0;
          while (s < bsp_ssecs.rdata[0,8]) {
            int16    d0x      = uninitialized;
            int16    d0y      = uninitialized;
            int16    d1x      = uninitialized;
            int16    d1y      = uninitialized;

            // get segment data
            bsp_segs_coords.addr      = bsp_ssecs.rdata[8,16] + s;
            bsp_segs_tex_height.addr  = bsp_ssecs.rdata[8,16] + s;
            bsp_segs_texmapping.addr  = bsp_ssecs.rdata[8,16] + s;
            // sector info (changes in loop)
            bsp_secs.addr             = bsp_ssecs.rdata[24,16];
++:
            // prepare movable data (if any)
            bsp_movables.addr         = bsp_segs_tex_height.rdata[40,8];

            //-------------------------
            // check for intersection
            //-------------------------
            v0x = bsp_segs_coords.rdata[ 0,16];
            v0y = bsp_segs_coords.rdata[16,16];
            v1x = bsp_segs_coords.rdata[32,16];
            v1y = bsp_segs_coords.rdata[48,16];
            d0x = v0x - ray_x;
            d0y = v0y - ray_y;
            d1x = v1x - ray_x;
            d1y = v1y - ray_y;
++:
            cs0_h = (d0y * ray_dx_m - d0x * ray_dy_m);
            cs1_h = (d1y * ray_dx_m - d1x * ray_dy_m);
++:
            if ((cs0_h<__signed(0) && cs1_h>=__signed(0)) || (cs1_h<__signed(0) && cs0_h>=__signed(0))) {
              int$FPl$ x0_h     = uninitialized;
              int$FPl$ y0_h     = uninitialized; // larger to hold FPm x FPm
              int$FPl$ x1_h     = uninitialized;
              int$FPl$ y1_h     = uninitialized; // larger to hold FPm x FPm
              int$FPl$ d_h      = uninitialized;
              int$FPl$ num      = uninitialized;
              int$FPl$ den      = uninitialized;

              //-------------------------
              // compute distance to intersection
              //-------------------------
++: // relax timing
              y0_h   =  (  d0x * ray_dx_m + d0y * ray_dy_m );
              y1_h   =  (  d1x * ray_dx_m + d1y * ray_dy_m );
++:
              x0_h   =  cs0_h;
              x1_h   =  cs1_h;
++:
              // d  = y0 + (y0 - y1) * x0 / (x1 - x0)
              num    = x0_h <<< $FPm$;
              den    = (x1_h - x0_h);
++: // relax timing
              (interp_m) <- divl <- (num,den);

              // d_h   = y0_h + (((y0_h - y1_h) >>> $FPm$) * interp_m);
              mula   = (y0_h - y1_h);
              mulb   = interp_m;
++: // relax timing
              (mulr) <- mull <- (mula,mulb);
              d_h    = y0_h + (mulr >>> $FPm$);
++:
              if (d_h > $1<<(FPm+1)$) { // check distance sign, with margin to stay away from 0
                int16    tmp1     = uninitialized;
                int16    tmp2     = uninitialized;
                int$FPl$ d_c_h    = uninitialized;
                int$FPw$ light    = uninitialized;
                int16    sec_c_h  = uninitialized;
                int$FPl$ num      = uninitialized;
                int$FPl$ den      = uninitialized;
                //-------------------------
                // hit!
                //-------------------------
                // -> correct to perpendicular distance ( * cos(alpha) )
                den     = d_h * sin_m.rdata;
                // -> compute inverse distance
                num     = $FPl$d$(1<<(FPl-2))$;
++: // relax timing
                (invd_w) <- divl <- (num,den); // (2^(FPl-2)) / d
                d_c_h   = den >>> $FPm+4$; // record corrected distance for tex. mapping
++: // relax timing
                //-------------------------
                // floor/ceiling heights
                //-------------------------
                // NOTE: signed, so always read in same width!
                tmp1    = bsp_secs.rdata[0,16];  // floor height
                sec_f_h = tmp1 - ray_z;
                tmp2    = bsp_secs.rdata[16,16]; // ceiling height
                sec_c_h = tmp2 - ray_z;
                {
                  int$FPl$ tmp1_h = uninitialized;
                  int$FPl$ tmp2_h = uninitialized;
++:
                  tmp1_h  = (sec_f_h * invd_w);     // h / d
++:
                  tmp2_h  = (sec_c_h * invd_w);     // h / d
++:
                  // obtain projected heights
                  (f_h) = to_h(tmp1_h);
                  (c_h) = to_h(tmp2_h);
                }
++:
                // clamp to top/bottom, shift for texturing
                sec_f_h_t = -1;
                if (btm > f_h) {
                  sec_f_h_t = - ((btm - f_h) * d_c_h); // offset texturing
                  f_h       = btm;
                } else { if (top < f_h) {
                  sec_f_h_t = - ((f_h - top) * d_c_h); // offset texturing
                  f_h       = top;
                } }
++:
                sec_c_h_t = 0;
                if (btm > c_h) {
                  sec_c_h_t = ((btm - c_h) * d_c_h); // offset texturing
                  c_h       = btm;
                } else { if (top < c_h) {
                  sec_c_h_t = ((c_h - top) * d_c_h); // offset texturing
                  c_h       = top;
                } }

                // prepare sector data for other sector (if any)
                bsp_secs.addr = bsp_segs_tex_height.rdata[24,16];

                //-------------------------
                // draw floor
                //-------------------------
                {
                  uint8 texid = uninitialized;
                  texid = bsp_secs_flats.rdata[0,8];
                  inv_y.addr = $doomchip_height//2$ - btm;
                  while (btm < f_h) {
                    int$FPw$ tmp2_m   = uninitialized;
                    int16    tmp_u    = uninitialized;
                    int16    tmp_v    = uninitialized;
                    int$FPw$ gu_m     = uninitialized;
                    int$FPw$ gv_m     = uninitialized;
                    int$FPw$ tr_gu_m  = uninitialized;
                    int$FPw$ tr_gv_m  = uninitialized;
                    int$FPw$ light    = uninitialized;
                    gv_m = (-sec_f_h)  * inv_y.rdata;
  ++: // relax timing
                    gu_m = (coltox.rdata * gv_m) >>> 8;
  ++: // relax timing
                    // NOTE: distance is gv_m>>4  (matches d_c_h r-shifted by FPw-1)
                    // transform plane coordinates
                    tr_gu_m = ((gu_m * cosview_m + gv_m * sinview_m) >>> $FPm$) + (ray_y<<<5);
                    tr_gv_m = ((gv_m * cosview_m - gu_m * sinview_m) >>> $FPm$) + (ray_x<<<5);
                    // light
                    tmp2_m  = (gv_m>>8) - 15;
                    (light) = lightFromDistance(tmp2_m);
  ++: // relax timing
                    // write pixel
                    tmp_u = (tr_gv_m>>5);
                    tmp_v = (tr_gu_m>>5);
                    (opac) <- writePixel <- (c,btm,tmp_u,tmp_v,texid,light,gv_m);
                    btm   = btm + 1;
                    inv_y.addr = $doomchip_height//2$ - btm;
                  }
                }

                //-------------------------
                // draw ceiling
                //-------------------------
                {
                  uint8 texid = uninitialized;
                  texid = bsp_secs_flats.rdata[8,8];
                  if (texid > 0 || (bsp_segs_tex_height.rdata[16,8] != 0)) { // draw sky if upper texture present
                    inv_y.addr = top - $doomchip_height//2$;
                    while (top > c_h) {
                      int$FPw$ tmp2_m   = uninitialized;
                      int16    tmp_u    = uninitialized;
                      int16    tmp_v    = uninitialized;
                      int$FPw$ gu_m     = uninitialized;
                      int$FPw$ gv_m     = uninitialized;
                      int$FPw$ tr_gu_m  = uninitialized;
                      int$FPw$ tr_gv_m  = uninitialized;
                      int$FPw$ light    = uninitialized;
                      gv_m = (sec_c_h)   * inv_y.rdata;
  ++: // relax timing
                      gu_m = (coltox.rdata * gv_m) >>> 8;
  ++: // relax timing
                      // transform plane coordinates
                      tr_gu_m = ((gu_m * cosview_m + gv_m * sinview_m) >>> $FPm$) + (ray_y<<<5);
                      tr_gv_m = ((gv_m * cosview_m - gu_m * sinview_m) >>> $FPm$) + (ray_x<<<5);
                      // light
                      tmp2_m  = (gv_m>>8) - 15;
                      (light) = lightFromDistance(tmp2_m);
  ++: // relax timing
                      // write pixel
                      tmp_u = (tr_gv_m>>5);
                      tmp_v = (tr_gu_m>>5);
                      (opac) <- writePixel <- (c,top,tmp_u,tmp_v,texid,light,gv_m);
                      top   = top - 1;
                      inv_y.addr = top - $doomchip_height//2$;
                    }
                  }
                }

                // tex coord u
                yoff   = bsp_segs_texmapping.rdata[32,16];
                xoff   = bsp_segs_texmapping.rdata[16,16];
                tc_u   = ((bsp_segs_texmapping.rdata[0,16] * interp_m) >> $FPm$) + xoff;

                // light
                {
                  int$FPw$ tmp2_m   = uninitialized;
                  tmp2_m = (d_c_h>>$FPm-1$) - 15;
                  (light) = lightFromDistance(tmp2_m);
                }
++: // relax timing

                //-------------------------
                // lower wall?
                //-------------------------
                if (bsp_segs_tex_height.rdata[0,8] != 0) {
                  int16    tmp1     = uninitialized;
                  int$FPl$ tmp1_h   = uninitialized;
                  int$FPw$ tex_v    = uninitialized;
                  int16     sec_f_o = uninitialized;
                  uint8     texid   = uninitialized;
                  texid     = bsp_segs_tex_height.rdata[0,8];
                  // if switch, possibly change texture
                  (has_switch) = is_switch(texid);
                  if (has_switch && bsp_segs_tex_height.rdata[40,8] != 0) {
                    // check movable status
                    if (bsp_movables.rdata[50,1] == 0) {
                      // use ON texture
                      texid = bsp_segs_tex_height.rdata[0,8] + 1;
                    }
                  }

                  tmp1      = bsp_secs.rdata[0,16]; // other sector floor height
                  sec_f_o   = tmp1 - ray_z;
++:
                  tmp1_h  = (sec_f_o * invd_w);
++:
                  sec_f_o_t = 0;
                  (f_o)     = to_h(tmp1_h);
                  if (btm > f_o) {
                    sec_f_o_t = ((btm - f_o) * d_c_h); // offset texturing
                    f_o       = btm;
                  } else { if (top < f_o) {
                    sec_f_o_t = ((f_o - top) * d_c_h); // offset texturing
                    f_o       = top;
                  } }
++:
                  if (bsp_segs_texmapping.rdata[64,1] == 0) {
                    // normal
                    tex_v   = (sec_f_o_t);
                  } else {
                    // lower unpegged
                    tex_v   = (sec_c_h_t) + ((c_h - f_o) * d_c_h);
                  }
                  j       = f_o-1;
                  while (j >= btm) {
                    int$FPl$ tmp1_h = uninitialized;
                    int16    tmp_u  = uninitialized;
                    int16    tmp_v  = uninitialized;
                    int16    tc_v   = uninitialized;
                    tc_v   = tex_v >> $FPm-1+4$;
                    tmp_u  = tc_u;
                    tmp_v  = tc_v + yoff;
                    tmp1_h = d_c_h>>3;
                    (opac) <- writePixel <- (c,j,tmp_u,tmp_v,texid,light,tmp1_h);
                    j      = j - 1;
                    tex_v  = tex_v + (d_c_h);
                  }
                  btm = f_o;
                }

                //-------------------------
                // upper wall?
                //-------------------------
                if ( (bsp_segs_tex_height.rdata[16,8] != 0) // upper texture present
                ||   (bsp_secs_flats.rdata[8,8] == 0
                   && bsp_segs_tex_height.rdata[8,8] != 0) // or opaque with sky above
                ) {
                  int$FPl$ tmp1_h = uninitialized;
                  int16    tmp1   = uninitialized;
                  uint8    texid  = uninitialized;

                  texid     = bsp_segs_tex_height.rdata[16,8];

                  if (bsp_segs_tex_height.rdata[24,16] == 65535) {
                    tmp1    = tmp2; // sec_c_h + ray_z; // sky case: use sector height
                  } else {
                    tmp1    = bsp_secs.rdata[16,16]; // other sector ceiling height
                  }
                  sec_c_o   = tmp1 - ray_z;
++:
                  tmp1_h    = (sec_c_o * invd_w);
++:
                  if (bsp_segs_texmapping.rdata[65,1] == 0) {
                    int$FPw$ tex_v  = uninitialized;
                    // normal
                    sec_c_o_t = -1;
                    (c_o)     = to_h(tmp1_h);
                    if (btm > c_o) {
                      sec_c_o_t = - ((btm - c_o) * d_c_h); // offset texturing
                      c_o       = btm;
                    } else { if (top < c_o) {
                      sec_c_o_t = - ((c_o - top) * d_c_h); // offset texturing
                      c_o       = top;
                    } }
                    tex_v   = (sec_c_o_t);
                    j       = c_o + 1;
                    while (j <= top) {
                      int$FPl$ tmp1_h = uninitialized;
                      int16    tmp_u  = uninitialized;
                      int16    tmp_v  = uninitialized;
                      int16    tc_v   = uninitialized;
                      tc_v   = tex_v >>> $FPm-1+4$;
                      tmp_u  = tc_u;
                      tmp_v  = tc_v + yoff;
                      tmp1_h = d_c_h>>3;
                      (opac) <- writePixel <- (c,j,tmp_u,tmp_v,texid,light,tmp1_h);
                      j      = j + 1;
                      tex_v  = tex_v - (d_c_h);
                    }
                    top = c_o;
                  } else {
                    int$FPw$ tex_v  = uninitialized;
                    // upper unpegged
                    (c_o)     = to_h(tmp1_h);
                    if (btm > c_o) {
                      c_o       = btm;
                    } else { if (top < c_o) {
                      c_o       = top;
                    } }
                    tex_v   = (sec_c_h_t);
                    j       = top;
                    while (j > c_o) {
                      int$FPl$ tmp1_h = uninitialized;
                      int16    tmp_u  = uninitialized;
                      int16    tmp_v  = uninitialized;
                      int16    tc_v   = uninitialized;
                      tc_v   = tex_v >>> $FPm-1+4$;
                      tmp_u  = tc_u;
                      tmp_v  = tc_v + yoff;
                      tmp1_h = d_c_h>>3;
                      (opac) <- writePixel <- (c,j,tmp_u,tmp_v,texid,light,tmp1_h);
                      j      = j - 1;
                      tex_v  = tex_v + (d_c_h);
                    }
                    top = c_o;
                  }
                }

                //-------------------------
                // middle wall
                //-------------------------
                if (bsp_segs_tex_height.rdata[8,8] != 0) {
                  uint8 texid = uninitialized;

                  texid = bsp_segs_tex_height.rdata[8,8];
                  // if switch, possibly change texture
                  (has_switch) = is_switch(texid);
                  if (has_switch && bsp_segs_tex_height.rdata[40,8] != 0) {
                    // check movable status
                    if (bsp_movables.rdata[50,1] == 0) {
                      // use ON texture
                      texid = bsp_segs_tex_height.rdata[8,8] + 1;
                    }
                  }

                  if (bsp_segs_texmapping.rdata[64,1] == 0) {
                    int$FPw$ tex_v  = uninitialized;
                    // normal
                    tex_v   = (sec_c_h_t);
                    j       = c_h;
                    while (j >= f_h) {
                      int$FPl$ tmp1_h = uninitialized;
                      int16    tmp_u  = uninitialized;
                      int16    tmp_v  = uninitialized;
                      int16    tc_v   = uninitialized;
                      tc_v   = tex_v >> $FPm-1+4$;
                      tmp_u  = tc_u;
                      tmp_v  = tc_v + yoff;
                      tmp1_h = d_c_h>>3;
                      (opac) <- writePixel <- (c,j,tmp_u,tmp_v,texid,light,tmp1_h);
                      j      = j - 1;
                      tex_v  = tex_v + (d_c_h);
                    }
                  } else {
                    int$FPw$ tex_v  = uninitialized;
                    // lower unpegged
                    tex_v   = (sec_f_h_t);
                    j       = f_h;
                    while (j <= c_h) {
                      int$FPl$ tmp1_h = uninitialized;
                      int16    tmp_u  = uninitialized;
                      int16    tmp_v  = uninitialized;
                      int16    tc_v   = uninitialized;
                      tc_v   = tex_v >> $FPm-1+4$;
                      tmp_u  = tc_u;
                      tmp_v  = tc_v + yoff;
                      tmp1_h = d_c_h>>3;
                      (opac) <- writePixel <- (c,j,tmp_u,tmp_v,texid,light,tmp1_h);
                      j      = j + 1;
                      tex_v  = tex_v - (d_c_h);
                    }
                  }
                  (opac) = is_opaque(texid);
                  if (opac) {
                    // close column
                    top = btm;
                  } // otherwise we keep going is if nothing happened!
                }

                if (top <= btm) { // column completed
                  // flush stack to stop
                  stack_ptr = 0;
                  break;
                }

              }
            }
            // next segment
            s = s + 1;
          }

          //-------------------------
          // draw things!
          //-------------------------
          // get things sector info
          bsp_secs.addr       = bsp_ssecs.rdata[24,16];
          bsp_secs_flats.addr = bsp_ssecs.rdata[24,16];
++:
          (seclight) = sectorLightLevel(bsp_secs_flats);
          s = 0;
          while (s < bsp_secs.rdata[32,8]) {
            int$FPl$ tmp1_h = uninitialized;
            int16    d0x    = uninitialized;
            int16    d0y    = uninitialized;
            int16    d1x    = uninitialized;
            int16    d1y    = uninitialized;
            int$FPl$ d_h    = uninitialized;

            all_things.addr = bsp_secs.rdata[40,8] + s;
++:
            // get the thing center x,y coordinates
            v0x = all_things.rdata[ 0,16];
            v0y = all_things.rdata[16,16];
            //__display("*** thing x%d y%d",v0x,v0y);
            // go to view space
            d0x    = v0x - ray_x;
            d0y    = v0y - ray_y;
++:
            d_h    = (  d0x * cosview_m + d0y * sinview_m ); // along center view ray
            tmp1_h = (- d0x * sinview_m + d0y * cosview_m ) >>> $FPm$; // ortho to center view ray
++:
            // is in front?
            if (d_h > $1<<(FPm+1)$) { // margin to stay away from 0
              // yes, in front
              uint8  sp_frame    = uninitialized;
              uint1  sp_mirrored = uninitialized;
              uint12 sel_angle   = uninitialized;
              uint8  sel_frame   = uninitialized;
              int16  sprt_w      = uninitialized;
              int16  sprt_h      = uninitialized;
              int16  screen_ctr  = uninitialized;
              int16  screen_w    = uninitialized;
              int10     cur_v    = uninitialized;
              uint$FPw$ v_accum  = uninitialized;
              int$FPw$  screen_h = uninitialized;
              int$FPw$  screen_y = uninitialized;
              int$FPw$  y_first  = uninitialized;
              int$FPw$  y_last   = uninitialized;
              int10  v_post      = uninitialized;
              int10  n_post      = uninitialized;
              int10  u           = uninitialized;
              int10  v           = uninitialized;
              int$FPw$ r         = uninitialized;
              uint8  pix         = uninitialized;
              int16  tmp1        = uninitialized;
              int16  tmp2        = uninitialized;
              int$FPw$ tmp1_m    = uninitialized;
              int$FPl$ invd_h    = uninitialized;
              int$FPl$ tmp3_h    = uninitialized;
              int$FPw$ light     = uninitialized;
              int16     sec_f_o  = uninitialized;

++: // relax timing
              // -> compute inverse distance
              (invd_h) <- divl <- ( $FPl$d$(1<<(FPl-2))$ , d_h );
              // shift distance for texturing (here d_h is shifted by FPm less
              // than for walls: not multiplied by sin_m)
              d_h     = d_h >>> 4;
              // -> light level
              {
                int$FPw$ tmp2_m   = uninitialized;
                tmp2_m  = (d_h>>$FPm-1$) - 15;
                (light) = lightFromDistance(tmp2_m);
              }
              // -> compute thing center screen x
              screen_ctr = (tmp1_h * invd_h) >>> $(4+FPl-2-2*FPm)$; // shift to end up in screen x space
++: // relax timing
              // -> on screen? NOTE: may pop, remove once working as it should be safe without
              // -> read angle at this column (prepare)
              xtoalpha.addr = $xtoalpha_offset$ + screen_ctr;
++:
              // -> get sprite frame data
              tmp1      = all_things.rdata[32,8];
              tmp2      = xtoalpha.rdata;
              sel_angle = ((1024+viewangle+tmp2-(tmp1<<5)) & 4095);
              sel_frame = (((time>>2) + s)&1); // firing, 2 frames
              (sp_frame,sp_mirrored) = spriteSelect(sel_angle,sel_frame);
              sprites_header   .addr = sp_frame + 20; // +20: firing
              sprites_colstarts.addr = sp_frame + 20;
++:
              // -> compute thing size
              sprt_w   = sprites_header.rdata[48,16];
              sprt_h   = sprites_header.rdata[32,16];
              screen_w = (sprt_w * invd_h) >>> $(5+FPl-2-2*FPm)$;
              screen_h = (sprt_h * invd_h) >>> $(5+FPl-2-2*FPm-15)$; // shift by 15 to keep precision
              // -> compute thing height
              tmp1    = bsp_secs.rdata[0,16]; // thing sector floor height
              sec_f_o = tmp1 - ray_z;
              tmp3_h  = (sec_f_o * invd_h) >>> $FPm$;
++: // relax timing
              tmp1_m = coltox.rdata; // widden for compare
              if (tmp1_m > screen_ctr - screen_w && tmp1_m < screen_ctr + screen_w) { // is current column covered?
                int$FPw$ tmp2_m = uninitialized;
                int$FPl$ tmp2_h = uninitialized;

                screen_y = tmp3_h;
                tmp2_h   = d_h>>3; // distance increment

                // --------------------------- sprite draw column
                tmp2_m  = tmp1_m - (screen_ctr - screen_w);
                u       = (tmp2_m * d_h) >> $1+FPm-1+4$;
                y_first = screen_y;
                y_last  = screen_y + screen_h - $1<<15$;
++:
                // retrieve column pointer
                if (sp_mirrored) {
                  sprites_colptrs.addr = sprites_colstarts.rdata + sprt_w - 1 - u;
                } else {
                  sprites_colptrs.addr = sprites_colstarts.rdata + u;
                }
++:
                sprites_data.addr = sprites_colptrs.rdata;
++:
                v_accum =  0;
                cur_v   = -1;
                n_post  =  0;
                r       =  y_last;
                (tmp1)  = to_h(r);
                while (r >= y_first && sprites_data.rdata != 255 && tmp1 >= 0) {

                  // initiate depth buffer read
                  depthBuffer.addr    = tmp1;
                  depthBuffer.wenable = 0;
                  // obtain low-precision v
                  v    = v_accum >> $FPm-1+4$;

                  while (cur_v < v) {
                    if (n_post == 0) {
                      // read next post
                      v_post            = sprites_data.rdata;
                      sprites_data.addr = sprites_data.addr + 1;
++:
                      // num in post
                      n_post            = sprites_data.rdata;
                      sprites_data.addr = sprites_data.addr + 2; // skip one
                    }
                    if (cur_v >= v_post) {
                      n_post = n_post - 1;
                      if (n_post == 0) {
                        // skip last
                        sprites_data.addr = sprites_data.addr + 2;
                      } else {
                        sprites_data.addr = sprites_data.addr + 1;
                      }
                    }
                    cur_v = cur_v + 1;
                    //__display("first %d last %d r %d v_accum %d v %d cur_v %d v_post %d",y_first,y_last,r,v_accum,v,cur_v,v_post);

                  }

                  if (v >= v_post && n_post != 0 && tmp1 < $doomchip_height$) {
                    pix    = sprites_data.rdata;
                    //__display("pix draw %d,%d = %d",c,r,pix);
                    () <- writeSpritePixel <- (c,tmp1,pix,light,tmp2_h);

                    v_accum = v_accum + d_h;
                    r       = r - $1<<15$;
                    (tmp1)  = to_h(r);
                  } else {
                    // yes, this is duplicated! but this allows to save cycles
                    // by minimizing the jumps between states
                    v_accum = v_accum + d_h;
                    r       = r - $1<<15$;
                    (tmp1)  = to_h(r);
                  }

                }
                // -----------------------------------------------

              }
            }
            s = s + 1;
          }


        }
      }
      // tell caller we are done with column
      colio.done = 1;
      // next column
      c = c + 1;
    }
++:

    // ----------------------------------------------
    // collisions
    // ----------------------------------------------
//if INTERACTIVE then
    viewsector = 1;
    colliding  = 0;
    onmovable  = 0;
    onmovable_dist = 0;
    // init recursion
    stack[stack_ptr] = $root$;
    stack_ptr  = 1;
    while (stack_ptr > 0) {
      stack_ptr = stack_ptr-1;
      n         = stack[stack_ptr];
      bsp_nodes_coords  .addr = n;
      bsp_nodes_children.addr = n;
++:
      if (n[15,1] == 0) {
        // internal node reached
        lx  = bsp_nodes_coords.rdata[0 ,16];
        ly  = bsp_nodes_coords.rdata[16,16];
        ldx = bsp_nodes_coords.rdata[32,16];
        ldy = bsp_nodes_coords.rdata[48,16];
        // which side are we on?
        dx   = ray_x - lx;
        dy   = ray_y - ly;
++: // relax timing
        csl  = (dx * ldy);
        csr  = (dy * ldx);
++: // relax timing
        if (csr > csl) {
          // front
          stack[stack_ptr  ] = bsp_nodes_children.rdata[ 0,16];
          stack[stack_ptr+1] = bsp_nodes_children.rdata[16,16];
        } else {
          stack[stack_ptr  ] = bsp_nodes_children.rdata[16,16];
          stack[stack_ptr+1] = bsp_nodes_children.rdata[ 0,16];
        }
        stack_ptr = stack_ptr + 2;
      } else {
        // sub-sector reached
        bsp_ssecs    .addr = n[0,14];
++: // wait for data
        // while here, track z
        if (viewsector) { // done only once on first column
          bsp_secs   .addr = bsp_ssecs.rdata[24,16];
++: // wait for data
          target_z   = bsp_secs.rdata[0,16] + 40; // floor height + eye level
          viewsector = 0;
        }
        // collision detection
        s = 0;
        while (s < bsp_ssecs.rdata[0,8]) {
          // get segment data
          bsp_segs_coords.addr      = bsp_ssecs.rdata[8,16] + s;
          bsp_segs_tex_height.addr  = bsp_ssecs.rdata[8,16] + s;
          bsp_segs_texmapping.addr  = bsp_ssecs.rdata[8,16] + s;
++:
          // prepare movable data (if any)
          bsp_movables.addr         = bsp_segs_tex_height.rdata[40,8];
          // prepare sector data for other sector (if any)
          bsp_secs.addr = bsp_segs_tex_height.rdata[24,16];
++:
          // determine the type of segment (can we walk across, is it a movable?)
          walkable   = 1;
          movableseg = 0;
          onesided   = 0;
          if (bsp_segs_tex_height.rdata[8,8] != 0) { // opaque wall
            walkable = 0;
            onesided = 1;
          } else { // here we assume all walls without a middle section are two sided
            int16  tmp1 = uninitialized;
            int16  tmp2 = uninitialized;
            // other sector floor height
            tmp1 = bsp_secs.rdata[0,16];
            // other sector ceiling height
            tmp2 = bsp_secs.rdata[16,16];
            // walkable?
            if (ray_z < tmp1 || ray_z > tmp2) {
              walkable = 0;
            }
          }
          // movable?
          if (bsp_segs_tex_height.rdata[40,8] != 0) {
            movableseg = 1;
          }
++:
          if ((walkable == 0) || (movableseg == 1)) {
            int16    d0x      = uninitialized;
            int16    d0y      = uninitialized;
            int16    d1x      = uninitialized;
            int16    d1y      = uninitialized;
            int16    ndx      = uninitialized;
            int16    ndy      = uninitialized;
            int$FPl$ d_h      = uninitialized;
            int$FPl$ l_h      = uninitialized;

            // segment endpoints
            v0x = bsp_segs_coords.rdata[ 0,16];
            v0y = bsp_segs_coords.rdata[16,16];
            v1x = bsp_segs_coords.rdata[32,16];
            v1y = bsp_segs_coords.rdata[48,16];
            // segment vector
            d0x = col_rx - v0x;
            d0y = col_ry - v0y;
            // orthogonal distance to wall segment
            // (segment is v1 - v0)
            ldx    = v1x - v0x;
            ldy    = v1y - v0y;
            ndx    = - ldy; // ndx,ndy is orthogonal to v1 - v0
            ndy    =   ldx;
    ++: // relax timing
            // dot products
            l_h    = ldx * d0x + ldy * d0y;
            d_h    = ndx * d0x + ndy * d0y;
    ++:
            if (onesided == 0 || d_h < 0) { // one sided only stops if d_h < 0
              int$FPl$ tmp1_h = uninitialized;
              int$FPl$ tmp2_h = uninitialized;
              int$FPl$ tmp3_h = uninitialized;
              if (d_h < 0) {
                tmp1_h = - d_h;
              } else {
                tmp1_h = d_h;
              }
              tmp2_h = (bsp_segs_texmapping.rdata[ 0,16] << 4) + (bsp_segs_texmapping.rdata[ 0,16] << 1); // seglen * (16 + 2)
              tmp3_h = bsp_segs_texmapping.rdata[48,16] << 5; // segsqlen
              // close to movable seg?
    ++:  // relax timing
              if (movableseg == 1) {
                //          vvv  detect from further away
                if (((tmp1_h>>2) < tmp2_h) && (l_h > 0) && l_h < (tmp3_h)) {
                  if (onmovable) {
                    // keep only closest
                    if (tmp1_h < onmovable_dist) {
                      onmovable_dist = tmp1_h;
                      onmovable      = bsp_movables.addr;
                    }
                  } else {
                    onmovable  = bsp_movables.addr;
                  }
                }
              }
    ++:  // relax timing
              if (walkable == 0) {
                // close to the wall?              vv margin to prevent going in between convex corners
                if ( (tmp1_h < tmp2_h) && (l_h > - 32) && l_h < (tmp3_h + 32) ) {
                  int$FPl$ num      = uninitialized;
                  int$FPl$ den      = uninitialized;

                  colliding = 1;
                  //// DEBUG
                  debug1    = movableseg;
                  debug2    = bsp_movables.addr;
                  debug3    = bsp_ssecs.rdata[8,16] + s;
                  // decollision,  pos = pos + (d.n) * n
    ++:  // relax timing
                  if (d_h < 0) {
                    num    =  - ((tmp2_h - tmp1_h) << $FPm$);
                  } else {
                    num    =    ((tmp2_h - tmp1_h) << $FPm$);
                  }
                  den    = bsp_segs_texmapping.rdata[0,16];
    ++:  // relax timing
                  (tmp1_h) <- divl <- (num,den);
                  num    = tmp1_h * ndx;
    ++:  // relax timing
                  (tmp2_h) <- divl <- (num,den);
                  col_rx = col_rx + (tmp2_h >>> $FPm$);
    ++:  // relax timing
                  num    = tmp1_h * ndy;
    ++:  // relax timing
                  (tmp2_h) <- divl <- (num,den);
                  col_ry = col_ry + (tmp2_h >>> $FPm$);
                }
              }
            }
          }
          s = s + 1;
        }
      }
    }
//end

    // ----------------------------------------------
    // motion movables
    // ----------------------------------------------
    bsp_movables.wenable = 0;
    bsp_movables.addr    = 1; // skip first (id=0 tags 'not a movable')
    while (bsp_movables.addr < num_bsp_movables) {
      if (bsp_movables.rdata[51,1] && bsp_movables.rdata[32,16] < 65535) { // active and drives a sector?
        int16 tmp1 = uninitialized;
        int16 tmp3 = uninitialized;

        ///// DEBUG
        debug0 = bsp_movables.addr;

        active = 1;
        // read sector
        bsp_secs    .wenable = 0;
        bsp_secs    .addr    = bsp_movables.rdata[32,16];
++:
        // floor or ceiling
        if (bsp_movables.rdata[48,1]) {
          tmp1 = bsp_secs.rdata[0,16];
        } else {
          tmp1 = bsp_secs.rdata[16,16];
        }
        // direction
        if (bsp_movables.rdata[50,1] == 0) {
          int16 tmp2 = uninitialized;
          // up
          tmp2 = bsp_movables.rdata[0,16]; // uph
          if (tmp1 < tmp2) {
            tmp3   = tmp1 + 1;
          } else {
            tmp3   = tmp1;
            active = 0;
          }
        } else {
          int16 tmp2 = uninitialized;
          // down
          tmp2 = bsp_movables.rdata[16,16]; // downh
          if (tmp1 > tmp2) {
            tmp3   = tmp1 - 1;
          } else {
            tmp3   = tmp1;
            active = 0;
          }
        }
++:
        // write back sector
        bsp_secs.wdata = bsp_secs.rdata;
        if (bsp_movables.rdata[48,1]) {
          bsp_secs.wdata = {bsp_secs.rdata[16,32],tmp3};
        } else {
          bsp_secs.wdata = {bsp_secs.rdata[32,16],tmp3,bsp_secs.rdata[0,16]};
        }
        bsp_secs.wenable = 1;
        // update movable if became inactive
++:
        if (active == 0) {
          bsp_movables.wdata       = {active,bsp_movables.rdata[0,51]};
          bsp_movables.wenable     = 1;
++:
          bsp_movables.wenable     = 0;
        }
      }
      // next
      bsp_movables.addr = bsp_movables.addr + 1;
    }
    bsp_secs.wenable = 0;

    // ----------------------------------------------
    // prepare next frame
    // ----------------------------------------------
++:
    time  = time  + 1;
    if ((time & 3) == 0) {
      rand  = rand * 31421 + 6927;
    }
++:
    frame = frame + 1;
$$if not INTERACTIVE and (not SIMULATION or USE_DEBUG_POS) then
    if (frame >= demo_path_len) {
      // reset
      frame     = 0;
      viewangle = $player_start_a$;
      ray_x     = $(player_start_x)$;
      ray_y     = $(player_start_y)$;
    }
    demo_path.addr = frame;
$$else

$$if ULX3S then
$$  ANGLE_SPEED   = 36
$$  FORWARD_SHIFT = FPm-3
$$else
$$  ANGLE_SPEED   = 12
$$  FORWARD_SHIFT = FPm-2
$$end

++:
    // viewangle
    if ((kpressed & 4) != 0) {
      viewangle   = viewangle + $ANGLE_SPEED$;
    } else {
    if ((kpressed & 8) != 0) {
      viewangle   = viewangle - $ANGLE_SPEED$;
    } }
    // forward motion
    if ((kpressed & 1) != 0) {
      ray_x   = col_rx + ((cosview_m) >>> $FORWARD_SHIFT$);
      ray_y   = col_ry + ((sinview_m) >>> $FORWARD_SHIFT$);
    } else {
    if ((kpressed & 2) != 0) {
      ray_x   = col_rx - ((cosview_m) >>> $FORWARD_SHIFT$);
      ray_y   = col_ry - ((sinview_m) >>> $FORWARD_SHIFT$);
    } }
    // side motion
    if ((kpressed &  64) != 0) {
      ray_x   = col_rx - ((sinview_m) >>> $FORWARD_SHIFT$);
      ray_y   = col_ry + ((cosview_m) >>> $FORWARD_SHIFT$);
    } else {
    if ((kpressed & 128) != 0) {
      ray_x   = col_rx + ((sinview_m) >>> $FORWARD_SHIFT$);
      ray_y   = col_ry - ((cosview_m) >>> $FORWARD_SHIFT$);
    } }
    // manual movables
    if (kpressblind == 0) {
      if ((kpressed & 16) != 0) {
        kpressblind = 1;
        // change movable direction
        bsp_movables.addr    = onmovable;
++:
        movabledata          = {1b1,~bsp_movables.rdata[50,1],bsp_movables.rdata[0,50]};
        bsp_movables.wdata   = movabledata;
        bsp_movables.wenable = 1;
++:
        bsp_movables.wenable = 0;
      }
    } else {
      kpressblind = kpressblind + 1;
    }

++:
    // up/down smooth motion
    if (ray_z < target_z) {
      if (ray_z + 3 < target_z) {
        ray_z = ray_z + 3;
      } else {
        ray_z = ray_z + 1;
      }
    } else { if (ray_z > target_z) {
      if (ray_z > target_z + 3) {
        ray_z = ray_z - 3;
      } else {
        ray_z = ray_z - 1;
      }
    } }
$$end

    // ----------------------------------------------
    // end of frame
    // ----------------------------------------------

    // wait for vsync to end
    // while (vsync == 0) {} //// TEST

  }
}
